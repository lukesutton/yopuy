/**
  A phantom-type used to indicate the type of response from a path encoded in a
  `Path` or `ChildPath`. In this case, a collection of `Resource`.
*/
public enum CollectionPath {}

/**
  A phantom-type used to indicate the type of response from a path encoded in a
  `Path` or `ChildPath`. In this case, a single `Resource`.
*/
public enum SingularPath {}

/**
  A phantom-type used to indicate the HTTP method associated with a `Path` or
  `ChildPath`.
*/
public enum GET {}

/**
  A phantom-type used to indicate the HTTP method associated with a `Path` or
  `ChildPath`.
*/
public enum POST {}

/**
  A phantom-type used to indicate the HTTP method associated with a `Path` or
  `ChildPath`.
*/
public enum PUT {}

/**
  A phantom-type used to indicate the HTTP method associated with a `Path` or
  `ChildPath`.
*/
public enum PATCH {}

/**
  A phantom-type used to indicate the HTTP method associated with a `Path` or
  `ChildPath`.
*/
public enum DELETE {}

/**
  This struct encodes the path to an operation on a remote resource or a
  collection. It uses generics and phantom-types to encode the `Resource` it
  relates to, the response type — a collection or single resource — and the
  HTTP method.

  It can then be passed to the `call` function on the `Service` type, which will
  execute the encoded operation.

  Here is an example of a path for deleting a record:

  ```swift
  let path = Path<User, SingularPath, DELETE>(path: "user/1")
  ```

  **Note:** In general usage, you should not need to construct an instance of
  this type. Instead they are generated by functions defined on `Resource`.
*/
public struct Path<R: Resource, Path, Method> {
    /**
      The path to the resource collection e.g. `users`, `posts`.
    */
    public let path: String
}
/**
  This struct encodes the _partial_ path to an operation on a remote resource or
  a collection. It has the same semantics as `Path` — encoding method etc. — but
  cannot be used to make a request. Instead it has to be appended to a `Path`.

  Imagine we have a hierarchy like this: `/groups/{group_id}/users/{user_id}`.
  We don't want to allow a path like `/users/1` to be used to make a request. So
  we encode it as a `ChildPath`. We would turn it into a qualified path using
  the `/(_:_:)` operator.

  **Note:** In general usage, you should not need to construct an instance of
  this type. Instead they are generated by functions defined on `Resource`.
*/
public struct ChildPath<R: ChildResource, Path, Method> {
    /**
      The path to the resource collection e.g. `users`, `posts`.
    */
    public let path: String
}

/**
  Appends a `ChildPath` to a `Path` yielding a new `Path`. This is the mechanism
  used for generating paths to resources and collections.

  Here is a version with manually constructed paths:

  ```swift
  let parent = Path<Group, SingularPath, GET>(path: "groups/1")
  let child = ChildPath<User, SingularPath, GET>(path: "users/1")
  let result = parent / child
  let path = result.path // "groups/1/users/1"
  ```

  Generally you wouldn't do this however. You would use the functions defined
  on your resources.

  ```swift
  let result = Group.show(1) / User.show(1)
  let path = result.path // "groups/1/users/1"
  ```

  The various constraints on this function give us the following properties:

  - Only `ChildPath` can be appended to `Path`, not `Path` to `Path` or
    `ChildPath` to `ChildPath`
  - The parent `Path` must point to a single resource, not a collection
  - The resources for the paths must have a parent/child relationship; see the
    `associatedtype Parent` declaration in `ChildResource`.
*/
public func / <P, C, F, M>(lhs: Path<P, SingularPath, GET>, rhs: ChildPath<C, F, M>) -> Path<C, F, M>
    where P: IsShowable, C: ChildResource, C.Parent == P {
    return Path(path: "\(lhs.path)/\(rhs.path)")
}
